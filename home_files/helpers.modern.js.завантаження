!function(){"use strict";class e{constructor(e,t,o){this.dateTimeMs=t,this.expiryMs=e,this.storage=o?JSON.parse(o):{},this.purge()}purge(){const e=this.dateTimeMs();for(var t in this.storage)if(this.storage.hasOwnProperty(t)){this.storage[t].expiry<e&&delete this.storage[t]}}get(e){const t=this.storage[e];if(t){if(!(t.expiry<this.dateTimeMs()))return t.value;delete this.storage[e]}}set(e,t){const o={expiry:this.dateTimeMs()+this.expiryMs,value:t};this.storage[e]=o}serialize(){return JSON.stringify(this.storage)}}const t=e=>JSON.stringify(e.ids).toLowerCase(),o=e=>e.ids.externalId.toLowerCase(),s=(e,t)=>e+o(t),r=(e,t)=>{const o={};for(let s=0;s<e.length;s++){o[t(e[s])]=s}return o},n=(e,r,n,u)=>{const c=[],i=[],a=[],p={};for(let d=0;d<r.length;d++){const g=r[d],l=t(g);a[d]||(a[d]=u(g));let h=!1;for(let t=0;t<n.length;t++){const r=n[t],u=o(r),c=s(l,r),g=e.get(c);void 0===g?(h=!0,p[u]||(i.push(r),p[u]=!0)):g&&(a[d].segmentations[t]={ids:r.ids,segment:g})}h&&c.push(g)}return{requestProductsOrGroups:c,requestSegmentations:i,responseFromCache:a,requestedSegmentations:p}},u=(e,t,o,s)=>{let r=[];r=r.concat(o.productResponseFromCache),r=r.concat(o.productGroupResponseFromCache),null!=s.products&&s.products.length>0&&c(e,o.productResponseFromCache,s.products,o.productOrderMap,o.segmentationOrderMap),null!=s.productGroups&&s.productGroups.length>0&&c(t,o.productGroupResponseFromCache,s.productGroups,o.productGroupOrderMap,o.segmentationOrderMap);for(let e=0;e<r.length;e++){const t=[];for(let o=0;o<r[e].segmentations.length;o++){const s=r[e].segmentations[o];s&&t.push(s)}r[e].segmentations=t}return{productCache:e,productGroupCache:t,response:r}},c=(e,r,n,u,c)=>{for(let i=0;i<n.length;i++){const a=n[i],p=t(a),d=r[u[p]];for(let t=0;t<a.segmentations.length;t++){const r=a.segmentations[t],n=o(r),u=s(p,r);e.set(u,r.segment||null),d.segmentations[c[n]]=r.segment?r:void 0}}},i=s=>{if((s.products?.length??0+s.productGroups?.length??0)>50)return Promise.reject(new Error("Too many products and product groups for a single call"));if(s.segmentations.length>10)return Promise.reject(new Error("Too many segmentations for a single call"));const c="MindboxProductSegmentsCache",i="MindboxProductGroupSegmentsCache",a=new e(3e5,Date.now,window.localStorage.getItem(c)),p=new e(3e5,Date.now,window.localStorage.getItem(i)),d=((e,s,u,c,i)=>{const a={products:[],productGroups:[],segmentations:[]};let p=[],d=[],g={},l={},h={},m={};if(null!=u&&u.length>0){const o=n(e,u,i,(e=>({product:e,segmentations:[]})));a.products=o.requestProductsOrGroups,a.segmentations=o.requestSegmentations,p=o.responseFromCache,g=r(u,t),m=o.requestedSegmentations}if(null!=c&&c.length>0){const e=n(s,c,i,(e=>({productGroup:e,segmentations:[]})));a.productGroups=e.requestProductsOrGroups;for(let t=0;t<e.requestSegmentations.length;t++){const s=e.requestSegmentations[t];m[o(s)]||a.segmentations.push(s)}d=e.responseFromCache,l=r(c,t)}return null!=i&&i.length>0&&(h=r(i,o)),{request:a,productResponseFromCache:p,productGroupResponseFromCache:d,productOrderMap:g,productGroupOrderMap:l,segmentationOrderMap:h}})(a,p,s.products,s.productGroups,s.segmentations);if(0==d.request.products?.length&&0==d.request.productGroups?.length){const e=u(a,p,d,{products:[],productGroups:[]});return new Promise(((t,o)=>{s.onSuccess(e.response),t()}))}return new Promise(((e,t)=>{window.mindbox("sync",{operation:"Tracker.CheckProductSegments",data:d.request,onError:e=>{s.onError(e),t(e)},onSuccess:t=>{const o=u(a,p,d,t);window.localStorage.setItem(c,o.productCache.serialize()),window.localStorage.setItem(i,o.productGroupCache.serialize()),s.onSuccess(o.response),e()}})}))},a={checkProductSegments:(e,t,o)=>i(o),getDeviceUUID:(e,t,o)=>((e,t)=>(t(e),Promise.resolve()))(t,o)};let p;p||(p={}),window.mindbox.helpers=a}();